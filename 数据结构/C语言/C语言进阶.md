# 一、数组

## 1、数组的含义

数组就是存储一批同类型数据的地方



## 2、定义数组

类型 数组名[常量表达式]

```c
int a[6]; // 定义一个整型数组，总共存放 6 个元素
char b[24]; // 定义一个字符型数组，总共存放 24 个元素
double c[3]; // 定义一个双精度浮点型数组，总共存放 3 个元素
```

在定义数组时，需要在数组名后边紧跟着一对方括号，其中用常量表达式来指定数组中元素的个数。因为只有告诉编译器元素的个数，编译器才能申请对应大小的内存给它存放。



## 3、访问数组

数组名[下标]

```c
a[0]; // 访问 a 数组中的第 1 个元素
b[1]; // 访问 b 数组中的第 2 个元素
c[5]; // 访问 c 数组中的第 6 个元素

// 注意：

int a[5]; // 创建一个具有 5 个元素的数组
a[0]; // 访问第 1 个元素的下标是 0，不是 1
a[5]; // 报错，因为第 5 个元素的下标是 a[4]
```



## 4、数组的初始化

在定义数组的同时对其各个元素进行赋值，称之为数组的初始化。

数组的初始化方式有很多，下边逐个给大家介绍！

1. 将数组中所有元素统一初始化为某个值，可以这么写：

   ```c
   int a[10] = {0}; // 将数组中所有元素初始化为 0
   ```

2. 如果是赋予不同的值，那么用逗号分隔开即可：

   ```c
   int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
   ```

3. 还可以只给一部分元素赋值，未被赋值的元素自动初始化为 0：

   ```c
   int a[10] = {1, 2, 3, 4, 5, 6}; // 表示为前边 6 个元素赋值，后边 4 个元素系统自动初始化为 0
   ```

4. 可以只给出各个元素的值，而不指定数组的长度（因为编译器会根据值的个数自动判断数组的长度）：

   ```c
   int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
   ```

5. C99 增加了一种新特性——指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而未被赋值的元素自动初始化为 0：

   ```c
   int a[10] = {[3] = 3, [5] = 5, [8] = [8]}; // 编译的时候记得加上 –std=c99 选项
   ```



## 5、变长数组（VLA，variable length array）

C99 标准新增变长数组（VLA，variable length array）的概念，这里的变长指的是数组的长度是在运行时才能决定，但一旦决定在数组的生命周期内就不会再变。

即下边代码是合法的：

```c
#include <stdio.h>

int main()
{
        int n, i;

        printf("请输入字符的个数：");
        scanf("%d", &n);

        char a[n+1]; 

        printf("请开始输入字符：");
        getchar(); // 将标准输入流中剩下的 '\n' 扔掉
        for (i = 0; i < n; i++)
        {
                scanf("%c", &a[i]);
        }
        a[n] = '\0';
        printf("你输入的字符串是：%s\n", a);

        return 0;
}
```



# 二、字符串处理函数

## 1、字符数组

C 语言是没有字符串类型的。那它是如何存放和表示字符串的呢？两种方式——字符串常量以及字符类型的数组。

字符串常量："C语言"，"JAVA"

字符数组：

可以先定义指定长度的字符数组，然后再给每个元素单独赋值：

```c
int main
{
    char str[10];

    str[0] = 'F';
    str[1] = 'i';
    str[2] = 's';
    str[3] = 'h';
    str[4] = 'C';
    str[5] = '\0';

    ……
}
```

还可以直接在定义的时候对字符数组进行初始化，这样会方便很多：

```c
int main
{
    // 初始化字符数组的每个元素
    char str1[10] = {'F', 'i', 's', 'h', 'C', '\0'};
    
    // 可以不写元素的个数，因为编译器会自动计算
    char str3[] = {'F', 'i', 's', 'h', 'C', '\0'};
    
    // 使用字符串常量初始化字符数组
    char str4[] = {"FishC"};
    
    // 使用字符串常量初始化，可以省略大括号
    char str5[] = "FishC";
}
```



## 2、字符串处理函数

在实际开发中，你经常会听到大牛说“避免重新造轮子”。如果能用得上官方提供的现成的函数，尽量不要自己去写，这样除了能够大幅度提供工作效率外，也会使你的程序更加稳定和快速。

为了方便大家平时查阅，我这里帮大家做了一个分类和归纳： [C 语言标准函数库分类](https://fishc.com.cn/thread-70614-1-1.html)

获取字符串的长度：[strlen](https://fishc.com.cn/thread-68741-1-1.html) 函数

拷贝字符串：[strcpy](https://fishc.com.cn/thread-70518-1-1.html) 函数和 [strncpy](https://fishc.com.cn/thread-70568-1-1.html) 函数

连接字符串：[strcat](https://fishc.com.cn/thread-70566-1-1.html) 函数和 [strncat](https://fishc.com.cn/thread-70569-1-1.html) 函数

比较字符串：[strcmp](https://fishc.com.cn/thread-70567-1-1.html) 函数和 [strncmp](https://fishc.com.cn/thread-70575-1-1.html) 函数



# 三、二维数组

## 1、二维数组的定义

定义二维数组的方法跟一位数组相似，使用方括号指定每个维度的元素个数：

类型 数组名[常量表达式] [常量表达式]

```c
int a[6][6]; // 6 * 6，6 行 6 列
char b[4][5]; // 4 * 5，4 行 5 列
double c[6][3]; // 6 * 3，6 行 3 列
```

注意：这里需要强调的是几行几列我们是从概念模型上来看的，也就是说，这样来看待二维数组，我们可以更容易理解。但从物理模型上看，无论是二维数组还是更多维的数组，在内存中仍然是以线性的方式存储的。

二维数组事实上就是在一维数组的基础上，每个元素存放一个数组。同样道理，三维数组，四维数组都是以同样的方式实现。



## 2、二维数组的访问

数组名[下标]

```c
a[0][0]; // 访问 a 数组中第 1 行第 1 列的元素
b[1][3]; // 访问 b 数组中第 2 行第 4 列的元素
c[3][3]; // 访问 c 数组中第 4 行第 4 列的元素
```

跟访问一位数组相似，同样是使用下标访问数组中的元素。同样需要注意下标的取值范围，以防止数组的越界访问。

比如 int a[3] [4]，其“行下标”的取值范围是 0~2，“列下标”的取值范围是 0~3，超出任何一个下标的访问都会造成越界。



## 3、二维数组的初始化

1. 由于二维数组在内存中是线性存放的，因此可以将所有的数据写在一个花括号内：

   ```c
   int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
   ```

   这样就是先将第 1 行 4 个元素初始化，再初始化第2行的元素。

2. 为了更直观地表示元素的分布，可以用大括号将每一行的元素括起来：

   ```c
   int a[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
   ```

   这样写的话表示会更加清晰：

   ```c
   int a[3][4] = {
           {1, 2, 3, 4},
           {5, 6, 7, 8},
           {9, 10, 11, 12}
   };
   ```

3. 二维数组也可以仅对部分元素赋初值：

   ```c
   int a[3][4] = {{1}, {5}, {9}};
   ```

   这样写是只对各行的第 1 列元素赋初值，其余元素初始化为 0。

4. 如果希望整个二维数组初始化为 0，那么直接在大括号里写一个 0 即可：

   ```c
   int a[3][4] = {0};
   ```

5. C99 同样增加了一种新特性：指定初始化的元素。这样就可以只对数组中的某些指定元素进行初始化赋值，而未被赋值的元素自动初始化为 0：

   ```c
   int a[3][4] = {[0][0] = 1, [1][1] = 2, [2][2] = 3};
   ```

6. 二维数组的初始化也能偷懒，让编译器根据元素的数量计算数组的长度。但只有第 1 维的元素个数可以不写，其他维度必须写上：

   ```c
   int a[][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
   ```



# 四、指针

## 1、内存是如何存放变量的

通过变量名对变量进行访问和存储是为了方便程序员而设计的，其实在内存中完全没有存储变量名的必要。

因为编译器知道具体每一个变量名对应的存放地址，所以当你读取某个变量的时候，编译器就会找到变量名所在的地址，并根据变量的类型读取相应范围的数据。

![image-20220419160634772](https://raw.githubusercontent.com/zsc-dot/pic/master/img/Git/image-20220419160634772.png)



## 2、指针和变量

通常我们所说的**指针，就是地址的意思**。C 语言中有专门的指针变量用于存放指针，跟普通变量不同，**指针变量存储的是一个地址**。

指针变量也有类型，它的类型就是存放的地址指向的数据类型。

![image-20220419160742292](https://raw.githubusercontent.com/zsc-dot/pic/master/img/Git/image-20220419160742292.png)

看图，上边我们又定义了两个指针变量：pa 和 pf，因为它们是指针变量，所以它们在内存中存放的是地址。这里我们分别存放了变量 a 和 f 的地址。

在我们的编译系统中，指针变量是占 4 个字节的空间，也就是说一个地址是占 4 个字节的空间。



## 3、定义指针变量

定义指针变量跟普通变量十分相似，只是中间多了一个星号（*）。

```c
char *pa; // 定义一个指向字符型的指针变量
int *pb; // 定义一个指向整型的指针变量
```

左侧的数据类型表示指针变量中存放的地址指向的内存单元的数据类型。

比如刚才的图中：

指针变量 pa 中存放字符变量 a 的地址，所以 pa 应该定义为字符型指针；

而指针变量 pf 中存放的是整型变量 f 的地址，所以 pb 就定义为整型指针。



## 4、取地址运算符和取值运算符

如果需要获取某个变量的地址，可以使用取地址运算符（&）：

```c
char *pa = &a;
int *pb = &f;
```

如果需要访问指针变量指向的数据，可以使用取值运算符（*）：

```c
printf("%c, %d\n", *pa, *pb);
```

这里要注意的是取值运算符跟定义指针用的都是星号（*），这属于符号的重用，在不同的地方有不同的意义：

在定义时表示定义一个指针变量；

在其他位置表示获取指针变量指向的变量的值。

直接通过变量名来访问变量的值，我们称之为直接访问；

通过指针变量这样的形式来访问变量的值，我们称之为间接访问，所以取值运算符有时候也叫间接运算符。



## 5、避免访问未初始化的指针

```c
#include <stdio.h>

int main()
{
    int *a;

    *a = 123; // 这里表示把初始化赋给*a的随机值覆盖掉

    return 0;
}
```

类似于上边这样的代码是很危险的，因为指针变量 a 到底指向哪里，我们没办法知道。这个道理就跟访问未初始化的变量一样，它的值是随机的。

这在指针变量里会很危险，因为后边代码对一个未知地址进行赋值，那么你可能会覆盖到系统的一些关键代码。系统通常都不会允许你这么干，程序这时候会被终止并报错。

更危险的是，偶尔这个指针变量里随机存放的是一个合法的地址，那么接下来的赋值就会导致那个位置的值莫名其妙地被修改。**这种类型的 Bug 是非常难以排查的**。

所以，在对指针进行间接访问时，必须确保它们已经被正确地初始化。



# 五、指针和数组

## 1、核心概念

虽然数组和指针关系密切，但数组绝不是指针。

```c
#include <stdio.h>

int main()
{
    int a;
    int *p = &a;

    printf("请输入一个整数：");
    scanf("%d", &a);
    printf("a = %d\n", a);

    printf("请重新输入一个整数：");
    scanf("%d", p); // 由于本身就是用的a的地址，所以这里直接取a的地址就行
    printf("a = %d\n", a);

    return 0;
}

```



## 2、数组名

数组名是数组第一个元素的地址，也是数组的首地址。



## 3、指向数组的指针

```c
int a[] = {1, 2, 3, 4, 5};
int *p;
p = a; // 语句1
p = &a[0]; // 语句2
```

因为数组名即数组第一个元素的地址，所以语句 1 和语句 2 是等价的，都是将数组 a 的首地址存放到指针变量 p 中。



## 4、指针的运算

当指针指向数组元素的时候，我们可以对指针变量进行加减运算，这样做的意义相当于指向距离指针所在位置向前或向后第 n 个元素。

比如 p+1 表示指向 p 指针指向的元素的下一个元素；p-1 则表示指向上一个元素。

需要郑重强调的是：p+1 并不是简单地将地址加 1，而是指向数组的下一个元素。



## 5、数组和指针哪里像

